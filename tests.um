import "std.um"

type (
	TestFn* = fn (ctx: ^Context): std::Err
	TestTuple = struct {
		test: TestFn
		name: str
		res: std::Err
	}

	Assert = struct { ctx: weak ^Context }
	Context* = struct {
		tests: map[str]TestTuple
		current_: weak ^TestTuple
		assert: Assert
		fmtWithColor: bool
	}
	
	Result* = struct {
		result: std::Err
		time: real
	}
)

fn eprintln(text: str = "") { fprintf(std::stderr(), "%s\n", text) }
fn eprint(text: str = "") { fprintf(std::stderr(), text) }

fn (c: ^Context) green(text: str): str { return c.fmtWithColor ? sprintf("\x1b[32m%s\x1b[39m", text) : text }
fn (c: ^Context) red(text: str): str { return c.fmtWithColor ? sprintf("\x1b[31m%s\x1b[39m", text) : text }
fn (c: ^Context) bold(text: str): str { return c.fmtWithColor ? sprintf("\x1b[1m%s\x1b[21m", text) : text }

fn newContext*(col: bool = false): ^Context {
	c := new(Context)
	c.assert = Assert { ctx: c }
	c.fmtWithColor = col
	return c
}

fn (c: ^Context) fail*(msg: str = "", code: int = -1): std::Err { return std::error(code, msg) }
fn (c: ^Context) pass*(msg: str = ""): std::Err { return std::error(0, msg) }
fn (c: ^Context) end*(): std::Err { return c.pass("test ended") }

fn (a: ^Assert) isTrue*(cond: bool, msg: str = ""): std::Err {
	c := a.ctx
	t := c.current_
	std::assert(t != null, "attempt to call an assertion outside of a test case")

	if t^.res.code == 0 && !cond {
		s := c^.red(sprintf("test '%s': assertion failed", t^.name))
		if msg != "" { s += sprintf("\nreason: '%s'", msg) }
		eprint(s)

		t^.res = c^.fail(s)
	}

	return t^.res
}

fn (a: ^Assert) isFalse*(cond: bool, msg: str = ""): std::Err { return a.isTrue(!cond, msg) }

fn (a: ^Assert) isOk*(e: std::Err, msg: str = ""): std::Err {
	c := a.ctx
	t := c.current_
	std::assert(t != null, "attempt to call an assertion outside of a test case")

	if t^.res.code == 0 && e.code != 0 {
		s := c^.red(sprintf(
			"test '%s': error code is not std::StdErr.ok (%i)\n",
			t^.name, e.code
		))
		
		s += sprintf("reason: '%s'", msg != "" ? msg : e.msg)

		eprint(s); t^.res = c^.fail(s, e.code)
	}

	return t^.res
}

fn (c: ^Context) newTestTuple(name: str, test: TestFn): TestTuple {
	e := sprintf("test '%s' already registered", name)
	for n, t in c.tests { std::assert(name != n /* || test != t.test */, e) }

	t := TestTuple {}
	t.name = name
	t.test = test
	t.res = c.pass("test passed")
	return t
}

fn (c: ^Context) registerTest*(name: str, test: TestFn) {
	t := c.newTestTuple(name, test)
	c.tests[name] = t
}

fn (c: ^Context) registerTests*(tests: map[str]TestFn) {
	for name, test in tests { c.registerTest(name, test) }
}

fn (c: ^Context) run*(quitIfErr: bool = true): (bool, map[str]Result) {
	results := make(map[str]Result)
	didFail := false
	passedTests := 0

	for n, t^ in c.tests {
		c.current_ = t

		time := std::clock()
		t.test(c)
		time = std::clock() - time

		if t.res.code != 0 {
			didFail = true
		} else {
			passedTests++
			eprint(c^.green(sprintf("test '%s': ok", t.name)))
		}
		eprintln(sprintf(" (%fs)\n", time))

		results[n] = Result { result: t.res, time: time }
	}

	l := len(c.tests)
	text := sprintf("%i of %i tests passed", passedTests, l)
	if passedTests == l { text = c^.bold(c^.green(text)) }
	eprintln(text)
	c.current_ = null

	if quitIfErr && didFail { exit(-1) }
	return didFail, results
}
