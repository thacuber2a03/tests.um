import "std.um"

//~~const VERSION
// The current version number of the library, formatted as specified by
// the [Semantic Versioning Specification](https://semver.org/).
const VERSION* = "0.2.0"
//~~

type (

//~~type TestFn
// The signature of a test function.
TestFn* = fn (ctx: ^Context)
//~~

//~~type TestInfo
// Information about a test.
TestInfo* = struct {
    func: TestFn
    name: str
    result: std::Err
    time: real
}
//~~

Assertions = struct { ctx: weak ^Context }

//~~type Context
// The definition of a testing context.
Context* = struct {
    // Fields:

    // `tests` - Holds all of the registered tests. You can query this array
    // after calling `run()` to see the results and time taken for each test.
    tests: []TestInfo

    // `current` - A weak pointer to the currently processed test.
    // It is only valid within the test functions.
    current: weak ^TestInfo

    // `assert` - Holds the assertion functions.
    assert: Assertions

    // `printWithColor` - Toggles color printing.
    printWithColor: bool

    // `compactOutput` - Whether to use the compact or the verbose output.
    compactOutput: bool
}
//~~

)

fn eprintln(text: str = "") { fprintf(std::stderr(), "%s\n", text) }
fn eprint(text: str = "") { fprintf(std::stderr(), text) }

fn (c: ^Context) green(text: str): str { return c.printWithColor ? sprintf("\x1b[32m%s\x1b[m", text) : text }
fn (c: ^Context) red(text: str): str { return c.printWithColor ? sprintf("\x1b[31m%s\x1b[m", text) : text }
fn (c: ^Context) bold(text: str): str { return c.printWithColor ? sprintf("\x1b[1m%s\x1b[m", text) : text }

//~~fn newContext
// Returns a new, default `Context`.
//
// Defaults:
// - `compactOutput`: `true`
// - `printWithColor`: `false`
fn newContext*(): ^Context {
//~~
    c := new(Context)
    c.assert = Assertions { ctx: c }

    c.compactOutput = true
    c.printWithColor = false

    return c
}

//~~fn (^Context) fail
// Marks this test as failed. You should immediately return once calling this.
fn (c: ^Context) fail*(msg: str, code: int = -1) {
//~~
    t := c.current
    std::assert(t != null, "attempt to call fail() outside of a test case")

    s := c.bold("X")
    if !c.compactOutput {
        s = sprintf("test '%s': %s", t.name, msg)
    }
    eprint(c.red(s))

    t.result = std::error(code, msg)
}

//~~fn (^Context) pass
// Marks this test as passing. You should immediately return once calling this.
fn (c: ^Context) pass*(msg: str = "") {
//~~
    t := c.current
    std::assert(t != null, "attempt to call pass() outside of a test case")

    s := "O"
    if !c.compactOutput {
        s = sprintf("test '%s': %s", t.name, msg)
    }
    eprint(c.green(s))

    t.result = std::error(0, msg)
}

//~~ fn (^Context) assert.isTrue
// Asserts that `cond` is true. If the resulting `bool` is false, the caller should return immediately.
// If `msg` is not `""`, prints an extra reason alongside the error.
fn (a: ^Assertions) isTrue*(cond: bool, msg: str = ""): bool {
//~~
    c := a.ctx
    t := c.current
    std::assert(t != null, "attempt to call an assertion outside of a test case")

    if t.result.code == 0 && !cond {
        s := "assertion failed!"
        if msg != "" { s += sprintf(" reason: '%s'", msg) }
        c.fail(s)
        return false
    }

    return true
}

//~~ fn (^Context) assert.isTrue
// Asserts that `cond` is false. Everything else from `assert.isTrue` applies.
// (Currently, this is literally just a call to `assert.isTrue` with the condition inverted.)
fn (a: ^Assertions) isFalse*(cond: bool, msg: str = ""): bool {
//~~
    return a.isTrue(!cond, msg)
}

//~~ fn (c: ^Context) assert.isOk
// Asserts that `e`'s code is 0. If the resulting `bool` is false, the caller should return immediately.
// If `msg` is not `""`, prints an extra reason alongside the error. If it is, it defaults to `e`'s error message.
fn (a: ^Assertions) isOk*(e: std::Err, msg: str = ""): bool {
//~~
    c := a.ctx
    t := c.current
    std::assert(t != null, "attempt to call an assertion outside of a test case")

    if t.result.code == 0 && e.code != 0 {
        s := sprintf("error code is not std::StdErr.ok (%i)\n", e.code)
        s += sprintf("reason: '%s'", msg != "" ? msg : e.msg)
        c.fail(s, e.code)
        return false
    }

    return true
}

fn (c: ^Context) newTestInfo(name: str, func: TestFn): TestInfo {
    e := sprintf("test '%s' already registered", name)
    for _, t^ in c.tests { std::assert(name != t.name, e) }

    t := TestInfo {}
    t.name = name
    t.func = func
    return t
}

//~~fn (^Context) registerTest
// Registers a single new test.
// Will throw a fatal error if the name is already registered with this context.
fn (c: ^Context) registerTest*(name: str, test: TestFn) {
//~~
    t := c.newTestInfo(name, test)
    c.tests = append(c.tests, t)
}

//~~fn (^Context) registerTests
// Registers various tests consecutively.
// Will throw a fatal error if any of the keys are registered as names for tests with this context.
fn (c: ^Context) registerTests*(tests: []TestInfo) {
//~~
    for _, t in tests {
        t.result.msg = "" // in case it was set
        c.tests = append(c.tests, t)
    }
}

//~~fn (^Context) run
// Runs each of the tests registered to this context, and returns whether any single one of them had an error.
//
// `quitIfErr` exits the application after every test is run, if any single one of them has any errors.
fn (c: ^Context) run*(quitIfErr: bool = true): bool {
//~~
    didFail := false
    passedTests := 0

    if c.compactOutput { eprint("results: ") }

    for _, t^ in c.tests {
        c.current = t

        time := std::clock()
        t.func(c)
        t.time = std::clock() - time

        if t.result.code != 0 {
            didFail = true
        } else {
            if t.result.msg == "" { c.pass("ok") }
            passedTests++
        }

        if !c.compactOutput { eprintln(sprintf(" (took %fs)\n", t.time)) }
    }

    if c.compactOutput {
        eprintln("\n")
        if didFail {
            eprintln(c.red(c.bold("failed tests:\n")))

            // TODO: should loop through all tests again?
            for _, t^ in c.tests {
                if t.result.code == 0 { continue }

                msg := sprintf(
                    "test '%s': %s",
                    t.name, t.result.msg
                )

                eprintln(sprintf("%s (took %fs)\n", c.red(msg), t.time))
            }
        }
    }

    l := len(c.tests)
    text := sprintf("%i of %i tests passed", passedTests, l)

    text = passedTests == l ? c.green(text) : c.red(text)
    eprintln(c.bold(text))

    c.current = null
    if quitIfErr && didFail { exit(-1) }
    return didFail
}
