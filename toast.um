import "std.um"

//~~const VERSION
// The current version number of the library, formatted as specified by
// the [Semantic Versioning Specification](https://semver.org/).
const VERSION* = "0.1.0"
//~~

type (

//~~type TestFn
// The signature of a test function.
TestFn* = fn (ctx: ^Context)
//~~

TestTuple = struct {
    test: TestFn
    name: str
    res: std::Err
}

Assert = struct { ctx: weak ^Context }

//~~type Context
// The definition of a testing context.
Context* = struct {
    tests: map[str]TestTuple
    current: weak ^TestTuple
    assert: Assert
    fmtWithColor: bool
}
//~~

//~~type Result
// The results of a test.
Result* = struct {
    result: std::Err
    time: real
}
//~~

)

fn eprintln(text: str = "") { fprintf(std::stderr(), "%s\n", text) }
fn eprint(text: str = "") { fprintf(std::stderr(), text) }

fn (c: ^Context) green(text: str): str { return c.fmtWithColor ? sprintf("\x1b[32m%s\x1b[39m", text) : text }
fn (c: ^Context) red(text: str): str { return c.fmtWithColor ? sprintf("\x1b[31m%s\x1b[39m", text) : text }
fn (c: ^Context) bold(text: str): str { return c.fmtWithColor ? sprintf("\x1b[1m%s\x1b[21m", text) : text }

//~~fn newContext
// Sets up and returns a new `Context`.
// `color` dictates whether the tests should print with color or not.
fn newContext*(color: bool = false): ^Context {
//~~
    c := new(Context)
    c.assert = Assert { ctx: c }
    c.fmtWithColor = color
    return c
}

//~~fn (^Context) fail
// Marks this test as failed. You should immediately return once calling this.
fn (c: ^Context) fail*(msg: str, code: int = -1) {
//~~
    t := c.current
    std::assert(t != null, "attempt to call fail() outside of a test case")
    eprint(c.red(sprintf("test '%s': %s", t.name, msg)))
    t.res = std::error(code, msg)
}

//~~fn (^Context) pass
// Marks this test as passing. You should immediately return once calling this.
fn (c: ^Context) pass*(msg: str = "") {
//~~
    t := c.current
    std::assert(t != null, "attempt to call pass() outside of a test case")
    eprint(c.green(sprintf("test '%s': ok", t.name)))
    t.res = std::error(0, msg)
}

//~~ fn (^Context) assert.isTrue
// Asserts that `cond` is true. If the resulting `bool` is false, the caller should return immediately.
// If `msg` is not `""`, prints an extra reason alongside the error.
fn (a: ^Assert) isTrue*(cond: bool, msg: str = ""): bool {
//~~
    c := a.ctx
    t := c.current
    std::assert(t != null, "attempt to call an assertion outside of a test case")

    if t.res.code == 0 && !cond {
        s := "assertion failed"
        if msg != "" { s += sprintf("\nreason: '%s'", msg) }
        c.fail(s)
        return false
    }

    return true
}

//~~ fn (^Context) assert.isTrue
// Asserts that `cond` is false. Everything else from `assert.isTrue` applies.
// (Currently, this is literally just a call to `assert.isTrue` with the condition inverted.)
fn (a: ^Assert) isFalse*(cond: bool, msg: str = ""): bool {
//~~
    return a.isTrue(!cond, msg)
}

//~~ fn (c: ^Context) assert.isOk
// Asserts that `e`'s code is 0. If the resulting `bool` is false, the caller should return immediately.
// If `msg` is not `""`, prints an extra reason alongside the error. If it is, it defaults to `e`'s error message.
fn (a: ^Assert) isOk*(e: std::Err, msg: str = ""): bool {
//~~
    c := a.ctx
    t := c.current
    std::assert(t != null, "attempt to call an assertion outside of a test case")

    if t.res.code == 0 && e.code != 0 {
        s := sprintf("error code is not std::StdErr.ok (%i)\n", e.code)
        s += sprintf("reason: '%s'", msg != "" ? msg : e.msg)
        c.fail(s, e.code)
        return false
    }

    return true
}

fn (c: ^Context) newTestTuple(name: str, test: TestFn): TestTuple {
    e := sprintf("test '%s' already registered", name)
    for n, t in c.tests { std::assert(name != n /* || test != t.test */, e) }

    t := TestTuple {}
    t.name = name
    t.test = test
    return t
}

//~~fn (^Context) registerTest
// Registers a single new test.
// Will throw a fatal error if the name is already registered with this context.
fn (c: ^Context) registerTest*(name: str, test: TestFn) {
//~~
    t := c.newTestTuple(name, test)
    c.tests[name] = t
}

//~~fn (^Context) registerTests
// Registers various tests consecutively.
// Will throw a fatal error if any of the keys are registered as names for tests with this context.
fn (c: ^Context) registerTests*(tests: map[str]TestFn) {
//~~
    for name, test in tests { c.registerTest(name, test) }
}

//~~fn (^Context) run
// Runs each of the tests registered to this context, and returns:
// - Whether any single one of them had an error
// - A map with the results of each one of the tests, with the key being the name of the test.
//
// `quitIfErr` exits the application after every test is run, if any single one of them has any errors.
fn (c: ^Context) run*(quitIfErr: bool = true): (bool, map[str]Result) {
//~~
    results := make(map[str]Result)
    didFail := false
    passedTests := 0

    for n, t^ in c.tests {
        c.current = t

        time := std::clock()
        t.test(c)
        time = std::clock() - time

        if t.res.code != 0 {
            didFail = true
        } else {
            if t.res.msg == "" { c.pass("ok") }
            passedTests++
        }

        eprintln(sprintf(" (took %fs)\n", time))

        results[n] = Result { result: t.res, time: time }
    }

    l := len(c.tests)
    text := sprintf("%i of %i tests passed", passedTests, l)

    text = passedTests == l ? c.green(text) : c.red(text)
    eprintln(c.bold(text))

    c.current = null
    if quitIfErr && didFail { exit(-1) }
    return didFail, results
}
